{"version":3,"sources":["../../app-src/util/ConnectionFactory.js"],"names":["stores","connection","ConnectionFactory","constructor","Error","getConnection","Promise","resolve","reject","openRequest","indexedDB","open","onupgradeneeded","e","_createStores","target","result","onsuccess","close","bind","onerror","console","log","error","name","forEach","store","objectStoreNames","contains","deleteObjectStore","createObjectStore","autoIncrement","closeConnection"],"mappings":";;;;;;AAAA;AACA,kBAAMA,SAAS,CAAC,aAAD,CAAf;;AAEA;AACA,gBAAIC,aAAa,IAAjB;;AAEA;AACA;AACA;AACO,kBAAMC,iBAAN,CAAwB;AAC3BC,8BAAc;;AAEV;AACA,0BAAM,IAAIC,KAAJ,CAAU,8CAAV,CAAN;AAEH;;AAED,uBAAOC,aAAP,GAAuB;AACnB,2BAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;;AAEpC;AACA,4BAAIP,UAAJ,EAAgB,OAAOM,QAAQN,UAAR,CAAP;;AAEhB;;AAEA;AACA,8BAAMQ,cAAcC,UAAUC,IAAV,CAAe,cAAf,EAA+B,CAA/B,CAApB;;AAEA;AACAF,oCAAYG,eAAZ,GAA8BC,KAAK;AAC/B;AACAX,8CAAkBY,aAAlB,CAAgCD,EAAEE,MAAF,CAASC,MAAzC;AACH,yBAHD;;AAKA;AACAP,oCAAYQ,SAAZ,GAAwBJ,KAAK;AACzB;AACAZ,yCAAaY,EAAEE,MAAF,CAASC,MAAtB;AACA;AACAE,oCAAQjB,WAAWiB,KAAX,CAAiBC,IAAjB,CAAsBlB,UAAtB,CAAR;AACA;AACAA,uCAAWiB,KAAX,GAAmB,MAAM;AACrB,sCAAM,IAAId,KAAJ,CAAU,4CAAV,CAAN;AACH,6BAFD;AAGA;AACAG,oCAAQN,UAAR;AACH,yBAXD;;AAaA;AACAQ,oCAAYW,OAAZ,GAAsBP,KAAK;AACvBQ,oCAAQC,GAAR,CAAYT,EAAEE,MAAF,CAASQ,KAArB;AACA;AACAf,mCAAOK,EAAEE,MAAF,CAASQ,KAAT,CAAeC,IAAtB;AACH,yBAJD;AAMH,qBArCM,CAAP;AAsCH;;AAED;AACA,uBAAOV,aAAP,CAAqBb,UAArB,EAAiC;AAC7BD,2BAAOyB,OAAP,CAAeC,SAAS;;AAEpB;AACA,4BAAIzB,WAAW0B,gBAAX,CAA4BC,QAA5B,CAAqCF,KAArC,CAAJ,EACIzB,WAAW4B,iBAAX,CAA6BH,KAA7B;;AAEJ;AACAzB,mCAAW6B,iBAAX,CAA6BJ,KAA7B,EAAoC;AAChCK,2CAAe;AADiB,yBAApC;AAGH,qBAVD;AAWH;;AAED,uBAAOC,eAAP,GAAyB;AACrB;AACA,wBAAI/B,UAAJ,EAAgBiB;AACnB;AAnE0B","file":"ConnectionFactory.js","sourcesContent":["//Armazena os nomes das stores existentes. Fica fora da classe por não ser permitido declarar propriedades\r\nconst stores = ['negociacoes']\r\n\r\n//Variável que auxilia na verificação se já há uma conexão ativa\r\nlet connection = null\r\n\r\n//A mesma conexão será utilizada na aplicação inteira\r\n//Apesar de toda conexão possuir o mnétodo close(), não será permitido chamá-lo\r\n//Retorna a definição da classe para que seja acessível no restante da aplicação.\r\nexport class ConnectionFactory {\r\n    constructor() {\r\n\r\n        //Passamos um erro quando o programador tenta instânciar a classe para que seja utilizado apenas o método static\r\n        throw new Error(\"Não é possível criar instâncias dessa classe\")\r\n\r\n    }\r\n\r\n    static getConnection() {\r\n        return new Promise((resolve, reject) => {\r\n\r\n            //Se uma conexão já foi criada, será retornada no resolve evitando percorrer novamente o processo de criação.\r\n            if (connection) return resolve(connection)\r\n\r\n            //Triade de eventos para a abertura de uma conexão com IndexDB\r\n\r\n            //O método open abre a conexão passando o nome da Store e sua versão\r\n            const openRequest = indexedDB.open('jscangaceiro', 2)\r\n\r\n            //Lógica a ser executada caso a coneão necessite ser criada ou de atualização\r\n            openRequest.onupgradeneeded = e => {\r\n                //Se a conexão for bem sucedida, será chamado o método responsável por criar a store\r\n                ConnectionFactory._createStores(e.target.result)\r\n            }\r\n\r\n            //Lógica a ser utilizada caso a negociação obtenha sucesso\r\n            openRequest.onsuccess = e => {\r\n                //Só será executado na primeira vez que a conexão for criada\r\n                connection = e.target.result\r\n                //Guarda a função original close p´resente em todas as conexões no escopo de connection\r\n                close = connection.close.bind(connection)\r\n                //Utilizando o Monkey Pack, sobreescrevemos a função original close presente em todas as conexões para que seja emitido um erro ao tentar chamá-lo diretamente.\r\n                connection.close = () => {\r\n                    throw new Error('Você não pode fechar diretamente a conexão')\r\n                }\r\n                //Se a conexão for bem sucedida, será enviada como retorno através do resolve\r\n                resolve(connection)\r\n            }\r\n\r\n            //Lógica a ser utilizada caso a conexão retorne um erro\r\n            openRequest.onerror = e => {\r\n                console.log(e.target.error)\r\n                //Se a conexão obter erro, será enviado como retorno através de reject\r\n                reject(e.target.error.name)\r\n            }\r\n\r\n        })\r\n    }\r\n\r\n    //Método criado para deixar clara a intenção de criar uma store\r\n    static _createStores(connection) {\r\n        stores.forEach(store => {\r\n\r\n            //Se já houver uma store com mesmo nome, está será excluida\r\n            if (connection.objectStoreNames.contains(store))\r\n                connection.deleteObjectStore(store)\r\n\r\n            //Será criada a nova store com as propriedades do objeto options passado como argumento.\r\n            connection.createObjectStore(store, {\r\n                autoIncrement: true\r\n            })\r\n        })\r\n    }\r\n\r\n    static closeConnection() {\r\n        //Chama a função close original\r\n        if (connection) close()\r\n    }\r\n}"]}